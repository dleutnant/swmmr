#' @useDynLib swmmr
#' @importFrom Rcpp sourceCpp
NULL

#' @title Read time series data from SWMM's .out file
#' @description Reads the binary output ('.out') generated by the stormwater 
#' management model 'SWMM' and creates a list of xts-objects.
#' @param file The file to be read.
#' @param iType Sets the result type: 0 for Subcatchments,
#' 1 for nodes, 2 for links, 3 for system variables. 
#' Leave empty for retrieving elements available.
#' @param object_name Sets the objects of which time series data is returned.
#' Leave empty for retrieving elements available.
#' @param vIndex Sets the variables to be read (s. Details).
#' Leave empty for retrieving elements available.
#' @param firstPeriod integer number of first period to be returned
#' @param lastPeriod integer number of last period to be returned
#' @param multiColumn if \code{TRUE} (the default is \code{FALSE}), the result
#' is a list of xts objects with each object containing all variables instead of 
#' a list of lists of xts objects.
#' @param byObject if \code{TRUE}, each top level list element represents an
#' object, otherwise a variable
#' @param method Integer number determining the method of reading the binary
#'   file. The default is method = 1. If multiColumn = TRUE and byObject = TRUE
#'   you may try method = 2 and see if performance is enhanced (intended effect)
#'   compared to method = 1. The results should be the same!
#' @return A list of a list of xts-objects (if \code{multiColumn = TRUE}) or a
#' list of xts-objects (if \code{multiColumn = FALSE}).
#' 
#' @examples  
#' \dontrun{
#' xts_list_of_results <- read_out("model.out")
#' } 
#' 
#' @seealso \code{\link[xts]{xts}}.
#' @details 
#' 
#' vIndex depends on the result type. Choices are...
#' 
#' for each \strong{subcatchment} variable:
#' \itemize{
#'  \item 0 for rainfall rate (in/hr or mm/hr),
#'  \item 1 for snow depth (inches or millimeters),
#'  \item 2 for evaporation loss (in/day or mm/day),
#'  \item 3 for infiltration loss (in/hr or mm/hr),
#'  \item 4 for runoff flow (flow units),
#'  \item 5 for groundwater flow into the drainage network (flow units),
#'  \item 6 for groundwater elevation (ft or m),
#'  \item 7 for soil moisture in the unsaturated groundwater zone (volume fraction),
#'  \item 7 + N for washoff concentration of each pollutant (mass/liter).
#' }
#' 
#' for each \strong{node} variable:
#' \itemize{
#'  \item 0 for water depth (ft or m above the node invert elevation),
#'  \item 1 for hydraulic head (ft or m, absolute elevation per vertical datum),
#'  \item 2 for stored water volume (including ponded water, ft3 or m3),
#'  \item 3 for lateral inflow (runoff + all other external inflows, in flow units),
#'  \item 4 for total inflow (lateral inflow + upstream inflows, in flow units),
#'  \item 5 for surface flooding (excess overflow when the node is at full depth, in flow units),
#'  \item 5 + N for concentration of each pollutant after any treatment (mass/liter),
#' }
#' 
#' for each \strong{link} variable:
#' \itemize{
#'  \item 0 for flow rate (flow units),
#'  \item 1 for average water depth (ft or m),
#'  \item 2 for flow velocity (ft/s or m/s),
#'  \item 3 for volume of water (ft3 or m3),
#'  \item 4 for capacity (fraction of full area filled by flow for conduits; control setting for pumps and regulators),
#'  \item 4 + N for concentration of each pollutant (mass/liter),
#' }
#' 
#' for each \strong{system-wide} variable:
#' \itemize{
#'  \item 0 for air temperature (deg. F or deg. C),
#'  \item 1 for total rainfall (in/hr or mm/hr),
#'  \item 2 for total snow depth (inches or millimeters),
#'  \item 3 for average losses (in/hr or mm/hr),
#'  \item 4 for total runoff (flow units),
#'  \item 5 for total dry weather inflow (flow units),
#'  \item 6 for total groundwater inflow (flow units),
#'  \item 7 for total RDII inflow (flow units),
#'  \item 8 for total external inflow (flow units),
#'  \item 9 for total direct inflow (flow units),
#'  \item 10 for total external flooding (flow units),
#'  \item 11 for total outflow from outfalls (flow units),
#'  \item 12 for total nodal storage volume ( ft3 or m3),
#'  \item 13 for potential evaporation (in/day or mm/day),
#'  \item 14 for actual evaporation (in/day or mm/day).
#' }
#' 
#' @rdname read_out
#' @export
read_out <- function(
  file = "", iType = NULL, object_name = NULL, vIndex = NULL, 
  firstPeriod = NULL, lastPeriod = NULL, multiColumn = FALSE,
  byObject = TRUE, method = 1L
)
{
  # open swmm out file
  list_of_results <- OpenSwmmOutFile(outFile = file)
  
  # close swmm out file
  on.exit(CloseSwmmOutFile())

  if (exists("error", list_of_results)) {
    warning("error reading out file")
    return(list_of_results)
  }
  
  # check version and raise warning
  if (list_of_results$meta$version < 51000) {
    warning("This package was developed and tested with '.out-files' of SWMM >= 5.1.010.
             Caution is advised when importing time series from older versions.")
  }

  # check if water pollutants are available
  PollNames <- if (identical(character(0), list_of_results$pollutants$names)) {
    NULL  
  } else {
    list_of_results$pollutants$names
  } 
                      
  # make selection of results more convenient
  iType <- .get_iType(iType = iType)$iType
  
  # retrieve times --> will probably move to Rcpp in near future
  times_seconds <- GetSwmmTimes()
  
  is_zero <- times_seconds == 0
  
  if (any(is_zero)) {
    clean_stop(
      sprintf("GetSwmmTimes() returned %d-times zero", sum(is_zero))
    )
  }
  
  time <- as.POSIXct(times_seconds, tz = "GMT", origin = "1899-12-30")

  maxPeriod <- length(time)
  
  if (is.null(firstPeriod)) {
    firstPeriod <- 1L
  }
  
  if (is.null(lastPeriod)) {
    lastPeriod <- maxPeriod
  }

  stop_if_out_of_range(firstPeriod, 1L, maxPeriod)
  stop_if_out_of_range(lastPeriod, 1L, maxPeriod)
    
  if (lastPeriod < firstPeriod) {
    clean_stop(
      "lastPeriod must be greater or equal to firstPeriod (", firstPeriod, ")!"
    )
  }
  
  # if iType is either subc, nodes or links ...
  iIndex <- if (iType < 3) {
    # get Index, i.e. the position of object
    .get_iIndex(list_of_results, iType, object_name)
  } else {
    # case system variables
    list(iIndex = 777, names = "system_variable")
  }

  # get vIndex, i.e. the type of variables 
  vIndex <- .get_vIndex(iType = iType, vIndex = vIndex, PollNames = PollNames)

  # provide timestamps
  order_by <- time[firstPeriod:lastPeriod]

  if (method == 2L) {
    
    if (!multiColumn || !byObject) {
      clean_stop(
        "method = 2 is only implemented for multiColumn = TRUE and ",
        "byObject = TRUE"
      )
    }
    
    result_list <- lapply(iIndex$iIndex, function(iIndex) {
      
      xts::xts(order.by = order_by, matrix(
        data = GetSwmmResultPart2(
          iType = iType, 
          iIndex = iIndex, 
          varIndices = vIndex$vIndex,
          firstPeriod = firstPeriod, 
          lastPeriod = lastPeriod
        ),
        ncol = length(vIndex$vIndex), 
        byrow = TRUE,
        dimnames = list(NULL, vIndex$names)
      ))
    })

    return(stats::setNames(result_list, iIndex$names))
  }
  
  # Continue with method = 1
    
  # for each iIndex, i.e. for each subcatchment, nodes or links ...
  # give list elements name of subcathments|nodes|links|sysvar
  arg_combis <- expand.grid(iIndex = iIndex$iIndex, vIndex = vIndex$vIndex)
  
  result_list <- lapply(seq_len(nrow(arg_combis)), function(i) {
    
    cat(sprintf("Reading time series %d/%d ... ", i, nrow(arg_combis)))
    
    series <- GetSwmmResultPart(
      iType = iType, 
      iIndex = arg_combis$iIndex[i], 
      vIndex = arg_combis$vIndex[i],
      firstPeriod = firstPeriod, 
      lastPeriod = lastPeriod
    )
    
    cat("ok.\n")
    
    series
  })
  
  indexObjects <- list(iIndex = iIndex, vIndex = vIndex)
  
  indexNames <- if (byObject) c("iIndex", "vIndex") else c("vIndex", "iIndex")

  result <- lapply(indexObjects[[indexNames[1]]][[1]], FUN = function(i) {
    
    data <- result_list[which(arg_combis[[indexNames[1]]] == i)]
    
    # create xts objects
    if (multiColumn) {
    
      xts::xts(order.by = order_by, matrix(
        do.call(c, data), 
        ncol = length(data), 
        dimnames = list(NULL, indexObjects[[indexNames[2]]]$names)
      ))
      
    } else {
      
      stats::setNames(nm = indexObjects[[indexNames[2]]]$names, lapply(
        data, xts::xts, order.by = order_by
      ))
    }
    
  })
  
  stats::setNames(result, indexObjects[[indexNames[1]]]$names)
}

# stop_if_out_of_range ---------------------------------------------------------
stop_if_out_of_range <- function(x, a, b)
{
  if (x < a || x > b) {
    clean_stop(
      deparse(substitute(x)), " must be a value between ", a, " and ", b, "!"
    )
  }
}

#' Get the swmm version the .out file was generated with
#' 
#' This function opens an .out file and extract the swmm version the file was 
#' generated with. It belongs to a set of helper functions which aim to simplify 
#' the work with .out files. The lifecycle of this function is considered 
#' experimental.
#' 
#' @inheritParams read_out
#' @return A vector of type integer
#' @examples
#' \dontrun{
#' version <- get_out_version("model.out")
#' } 
#' @rdname get_out_version
#' @export
get_out_version <- function(file = "") {
  
  # get the content
  list_of_results <- get_out_content(file)
  
  # return version information
  list_of_results$meta$version
}

#' Get the content of an .out file.
#' 
#' This function opens an .out file and lists all available time series data.
#' Currently, the list is returned 'as is' which might change in future. 
#' It belongs to a set of helper functions which aim to simplify 
#' the work with .out files. The lifecycle of this function is considered 
#' experimental.
#' 
#' @inheritParams read_out
#' @return A list showing the available content.
#' @examples
#' \dontrun{
#' content <- get_out_content("model.out")
#' } 
#' @rdname get_out_content
#' @export
get_out_content <- function(file = "") {
  
  # open swmm out file
  list_of_results <- OpenSwmmOutFile(outFile = file)
  
  # close swmm out file
  on.exit(CloseSwmmOutFile())
  
  # check error
  if (exists("error", list_of_results)) {
    warning("error reading out file")
  }
  
  list_of_results
}
